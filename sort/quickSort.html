<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>12.3.3 快速排序</title>
    <script src="./sportUtilCopy.js"></script>
  </head>
  <body>
     <pre>
          快速排序是处理大数据集合最快的排序算法之一；
          分而治之，
          通过递归的方式，将数据依次分解为包含较小元素 和 较大元素的不同子序列，
     </pre>

    <pre>
         利用主定理分析时间复杂度

         经常听人谈起各种排序算法的时间复杂度，这个是O(n2)的，那个是O(n)的，这些人讲起来可谓滔滔不绝，但是你停下来问问他为什么这个是这个复杂度，他是怎么算出来的？往往没几个人能说出来。这个是一个浮躁的社会，大家都追求速度，到处复制，粘贴代码，拿人家的代码跑一便，就说自己会了这个，会了那个..

也许有人觉得算法分析的太深没有用，但是笔者认为，有时候了解细节很重要，比如快速排序算法的时间复杂度，有时候是O(nlgn), 有时候就是O(n2), 在你不知道自己数据特性的情况下，很难选择是否使用快速排序，因为他并不总是最快的。

说了些没用的，让我们进入正题吧：

为了分析快速排序的时间复杂度，请先看下面的主定理：

主定理: T [n] = aT[n/b] + f (n)
其中 a >= 1 and b > 1 是常量 并且 f (n) 是一个渐近正函数， 为了使用这个主定理，您需要考虑下列三种情况：




想必大家都知道快速排序的过程，如果对这个过程有什么不了解，请参考下文：


快速排序的每一次划分把一个 问题分解成两个子问题，其中的关系可以用下式表示：

T[n] = 2T[n/2] + O(n) 其中O(n)为PARTITION()的时间复杂度，对比主定理，

T [n] = aT[n/b] + f (n)

我们的快速排序中：a = 2, b = 2, f(n) = O(n)



那么为什么还有最坏情况呢？

考虑如下极端情况，

T[n] = T[n-1] + T[1] + O(n),
问题来了，这一次的划分白玩了，划分之后一边是一个，一边是n-1个，这种极端情况的时间复杂度就是O(n2).


总结
理解了主定理好多算法分析就迎刃而解了，本文没有给出注定理的证明，因为对于大家意义不大，感兴趣的读者可以参考相关的书籍。最后用一句话总结：天下大事必做于细，差之毫厘有时候真会谬之千里..

注：本文在发布的过程中由于文章里面有公式，不能发布，故改传了两张图..
另外，本文叙述的master method（主定理）并非本人原创，而是源自互联网，开始时本人并没有感觉此处会引起误解因为称得上定理的东西都不是这种随笔类的文章可以原创的，但是还是有人觉得没说清楚，于是在此给予澄清。

    </pre>
      <script>
          function qSort(list) {
              if(list.length == 0) {
                  return [];
              }
              var lesser = [];
              var greater = [];
              var pivot = list[0];
              for(var i =1;i<list.length;i++) {
                console.log("基准值： "+pivot+"当前元素："+list[i]);
                  if(list[i] < pivot) {
                       console.log("移动 "+list[i]+" 到左边 ");
                       lesser.push(list[i]);
                  }else {
                       console.log("移动："+list[i]+" 到右边 ");
                       greater.push(list[i]);
                  }
              }
              return qSort(lesser).concat(pivot,qSort(greater));
          }
         var a = [];
         for(var i =0;i<10;++i) {
            a[i] = Math.floor((Math.random()*100)+1);
         }
         console.log(a);
         console.log(qSort(a));
      </script>
  </body>
</html>
